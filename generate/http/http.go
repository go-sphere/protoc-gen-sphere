package http

import (
	"fmt"
	"net/http"
	"os"
	"slices"
	"strings"

	validatepb "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	"github.com/go-sphere/protoc-gen-sphere/generate/parser"
	"github.com/go-sphere/protoc-gen-sphere/generate/template"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	deprecationComment = "// Deprecated: Do not use."
)

const (
	contextPackage  = protogen.GoImportPath("context")
	validatePackage = protogen.GoImportPath("buf.build/go/protovalidate")
)

var methodSets = make(map[string]int)

func GenerateFile(gen *protogen.Plugin, file *protogen.File, conf *Config) (*protogen.GeneratedFile, error) {
	if len(file.Services) == 0 || !hasHTTPRule(conf.Omitempty, file.Services) {
		return nil, nil
	}
	filename := file.GeneratedFilenamePrefix + ".sphere.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	generateFileHeader(gen, file, g)
	err := generateFileContent(file, g, conf)
	if err != nil {
		return nil, err
	}
	return g, nil
}

func generateFileHeader(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-sphere. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func generateFileContent(file *protogen.File, g *protogen.GeneratedFile, conf *Config) error {
	if len(file.Services) == 0 {
		return nil
	}
	genConf := NewGenConf(g, conf)
	generateGoImport(file, g, conf, genConf)
	for _, service := range file.Services {
		err := generateService(g, service, genConf)
		if err != nil {
			return err
		}
	}
	return nil
}

func generateGoImport(file *protogen.File, g *protogen.GeneratedFile, conf *Config, genConf *GenConfig) {
	didImport := make(map[protogen.GoImportPath]bool)
	g.P("var _ = new(", contextPackage.Ident("Context"), ")")
	for _, ident := range []protogen.GoIdent{conf.RouterType, conf.ContextType, conf.ErrorRespType} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = new(", ident, ")")
		}
	}
	for _, ident := range []protogen.GoIdent{conf.ParseFormFunc, conf.ParseUriFunc, conf.ParseJsonFunc} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = ", ident)
		}
	}
	for _, ident := range []protogen.GoIdent{conf.DataRespType} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = new(", ident, "[any])")
		}
	}
	for _, ident := range []protogen.GoIdent{conf.ServerHandlerFunc} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = ", ident, "[any]")
		}
	}
LOOP:
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if hasValidateOptionsInMessage(method.Input) || slices.ContainsFunc(method.Input.Fields, hasValidateOptions) {
				ident := validatePackage.Ident("Validate")
				g.P("var _ = ", ident)
				genConf.packageDesc.ValidateFunc = g.QualifiedGoIdent(ident)
				break LOOP
			}
		}
	}
	g.P()
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service, conf *GenConfig) error {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	sd := &template.ServiceDesc{
		ServiceType: service.GoName,
		ServiceName: string(service.Desc.FullName()),
		Package:     conf.packageDesc,
	}
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			logWarn("method `%s.%s` is streaming, it will be ignored. File: `%s`",
				method.Parent.Desc.Name(),
				method.Desc.Name(),
				method.Parent.Location.SourceFile,
			)
			continue
		}
		rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
		if rule != nil && ok {
			for _, bind := range rule.AdditionalBindings {
				if desc, err := buildHTTPRule(g, service, method, bind, conf); err == nil {
					sd.Methods = append(sd.Methods, desc)
				}
			}
			if desc, err := buildHTTPRule(g, service, method, rule, conf); err == nil {
				sd.Methods = append(sd.Methods, desc)
			}
		} else if !conf.omitempty {
			// Method with no http_rule defined, automatically generating a default POST method.
			path := fmt.Sprintf("%s/%s/%s", conf.omitemptyPrefix, service.Desc.FullName(), method.Desc.Name())
			res := &parser.HttpRule{
				Path:         path,
				Method:       http.MethodPost,
				HasBody:      true,
				Body:         "*",
				ResponseBody: "",
			}
			desc, err := buildMethodDesc(g, method, res, conf)
			if err != nil {
				return err
			}
			sd.Methods = append(sd.Methods, desc)
		}
	}
	if len(sd.Methods) != 0 {
		content, err := sd.Execute()
		if err != nil {
			return err
		}
		g.P(content)
		g.P("\n\n")
	}
	return nil
}

func hasHTTPRule(omitempty bool, services []*protogen.Service) bool {
	for _, service := range services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			if !omitempty {
				return true
			}
			ext := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
			if ext == nil {
				continue
			}
			rule, ok := ext.(*annotations.HttpRule)
			if rule != nil && ok {
				return true
			}
		}
	}
	return false
}

func hasValidateOptions(field *protogen.Field) bool {
	opts := field.Desc.Options().(*descriptorpb.FieldOptions)
	return proto.HasExtension(opts, validatepb.E_Field)
}

func hasValidateOptionsInMessage(msg *protogen.Message) bool {
	return proto.HasExtension(msg.Desc.Options(), validatepb.E_Message)
}

func buildHTTPRule(g *protogen.GeneratedFile, service *protogen.Service, m *protogen.Method, rule *annotations.HttpRule, conf *GenConfig) (*template.MethodDesc, error) {
	res := parser.ParseHttpRule(rule)
	if res.Path == "" {
		res.Path = fmt.Sprintf("%s/%s/%s", conf.omitemptyPrefix, service.Desc.FullName(), m.Desc.Name())
	}
	md, err := buildMethodDesc(g, m, res, conf)
	if err != nil {
		return nil, err
	}
	if _, ok := parser.NoBodyMethods[res.Method]; ok {
		if rule.Body != "" {
			logWarn("method `%s.%s` body should not be declared. File: `%s`",
				m.Parent.Desc.Name(),
				m.Desc.Name(),
				m.Parent.Location.SourceFile,
			)
		}
	} else {
		if rule.Body == "" {
			logWarn("method `%s.%s` body is not declared. File: `%s`",
				m.Parent.Desc.Name(),
				m.Desc.Name(),
				m.Parent.Location.SourceFile,
			)
		}
	}
	return md, nil
}

func buildMethodDesc(g *protogen.GeneratedFile, m *protogen.Method, rule *parser.HttpRule, conf *GenConfig) (*template.MethodDesc, error) {
	route, err := parser.GinRoute(rule.Path)
	if err != nil {
		return nil, fmt.Errorf("method `%s.%s` route `%s` parse error: %v. File: `%s`",
			m.Parent.Desc.Name(),
			m.Desc.Name(),
			rule.Path,
			err,
			m.Parent.Location.SourceFile,
		)
	}
	defer func() { methodSets[m.GoName]++ }()

	comment := parser.MethodCommend(m)
	needValidate := hasValidateOptionsInMessage(m.Input) || slices.ContainsFunc(m.Input.Fields, hasValidateOptions)

	vars, err := parser.GinURIParams(m, route)
	if err != nil {
		return nil, err
	}

	forms, err := parser.GinQueryForm(m, rule.Method, vars)
	if err != nil {
		return nil, err
	}

	swag := &parser.SwagParams{
		Method:        rule.Method,
		Path:          parser.ConvertGinToSwaggerPath(route),
		Auth:          conf.swaggerAuth,
		PathVars:      vars,
		QueryVars:     forms,
		Body:          rule.Body,
		ResponseBody:  rule.ResponseBody,
		DataResponse:  conf.packageDesc.DataResponseType,
		ErrorResponse: conf.packageDesc.ErrorResponseType,
	}

	swagger, err := parser.BuildAnnotations(g, m, swag)
	if err != nil {
		return nil, err
	}

	bodyPath := strings.Join(parser.ProtoKeyPath2GoKeyPath(m.Input, strings.Split(rule.Body, ".")), ".")
	if bodyPath != "" {
		bodyPath = "." + bodyPath
	}

	responsePath := strings.Join(parser.ProtoKeyPath2GoKeyPath(m.Output, strings.Split(rule.ResponseBody, ".")), ".")
	if responsePath != "" {
		responsePath = "." + responsePath
	}

	response := g.QualifiedGoIdent(m.Output.GoIdent)
	if responsePath != "" {
		responseField := parser.FindProtoField(m.Output, strings.Split(rule.ResponseBody, "."))
		if responseField == nil {
			return nil, fmt.Errorf("method `%s.%s` field `%s` not found in message `%s`. File: `%s`",
				m.Parent.Desc.Name(),
				m.Desc.Name(),
				responsePath,
				m.Output.Desc.Name(),
				m.Parent.Location.SourceFile,
			)
		}
		response = parser.ProtoTypeToGoType(g, responseField, true)
	} else {
		response = "*" + response
	}

	return &template.MethodDesc{
		Name:         m.GoName,
		OriginalName: string(m.Desc.Name()),
		Num:          methodSets[m.GoName],
		Comment:      comment,

		Request:  g.QualifiedGoIdent(m.Input.GoIdent),
		Response: response,
		Reply:    g.QualifiedGoIdent(m.Output.GoIdent),

		Path:   route,
		Method: rule.Method,

		HasVars:      len(vars) > 0,
		HasQuery:     len(forms) > 0,
		HasBody:      rule.HasBody,
		NeedValidate: needValidate,

		Swagger: swagger,

		Body:         bodyPath,
		ResponseBody: responsePath,
	}, nil
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func logWarn(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: "+format+"\n", args...)
}
